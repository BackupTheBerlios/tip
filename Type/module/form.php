<?php
/* vim: set expandtab shiftwidth=4 softtabstop=4 tabstop=4 foldmethod=marker: */

/**
 * TIP_Form definition file
 *
 * LICENSE: This source file is subject to the New BSD license that is 
 * available through the world-wide-web at the following URI:
 * http://www.opensource.org/licenses/bsd-license.php
 * If you did not receive a copy of the New BSD License and are unable to
 * obtain it through the web, please send a note to license@php.net so we
 * can mail you a copy immediately.
 *
 * @author    Nicola Fontana <ntd@entidi.it>
 * @copyright Copyright &copy; 2006-2008 Nicola Fontana
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @package   TIP
 * @since     0.0.1
 */

/** Html_QuickForm PEAR package */
require_once 'HTML/QuickForm.php';

/**
 * Form generator
 *
 * Manages all the forms generated by the TIP system using the QuickForm PEAR
 * package.
 *
 * @package TIP
 */
class TIP_Form extends TIP_Module
{
    //{{{ Properties

    /**
     * A reference to the master content instance
     * @var TIP_Content
     */
    protected $master = null;

    /**
     * The file to run on form rendering
     * @var string
     */
    protected $form_template = 'form';

    /**
     * The type of action this form must perform
     * @var TIP_FORM_ACTION_...
     */
    protected $action = null;

    /**
     * Action name
     *
     * Action identifier to use in localizing the title.
     *
     * For basic actions, such as 'add', 'delete' and 'edit', you can leave it
     * null: the value will default to the content of the 'action' property.
     *
     * @var string
     */
    protected $action_id = null;

    /**
     * An array of fields structures, as returned by TIP_Data::getFields()
     *
     * Setting this property you can choose the fields to manipulate.
     * Leave it null for full automatic fields management.
     *
     * @var array
     */
    protected $fields = null;

    /**
     * An array of field ids to keep frozen
     * @var array
     */
    protected $readonly = array();

    /**
     * Wheter to include a captcha element in the form
     * @var boolean
     */
    protected $captcha = false;

    /**
     * A sum of TIP_FORM_BUTTON_... constants: leave it null to use
     * default buttons regardling the requested action
     *
     * @var int
     */
    protected $buttons = null;

    /**
     * An associative array of default values provided by the application
     *
     * To this array, that initially will contain the defaults explicitely
     * set in the configuration options or directly by the module, will be
     * merged (with higher precedence) the default values provided by GETs.
     *
     * @var array
     */
    protected $defaults = array();

    /**
     * Validation type, as described in HTML_QuickForm
     * @var string
     */
    protected $validation = 'server';

    /**
     * Validation callback
     *
     * Function to call before processing the data. It takes one argument:
     * the associative array of values to validate. This callback must return
     * true to process the record, or false to skip the processing.
     *
     * This callback can be useful to provide additional validations (other
     * than the ones provided by HTML_QuickForm) that need complex tasks.
     *
     * @var callback
     */
    protected $validator = null;

    /**
     * Process callback
     *
     * Function to call to process the data. This callback should take
     * two arguments:
     *
     * - &$row:    The associative array of validated values
     * - $old_row: The old associative array
     *             (usually the $this->_defaults array) or null
     *
     * By default this callback is null. If the form needs to process
     * the form and "on_process" is still undefined, an error is raised.
     *
     * The return value must be %true on success or %false on error.
     * Accordling to the return value, a notification message (error or
     * info) will be generated.
     *
     * @var callback
     */
    protected $on_process = null;

    /**
     * The render mode for not-validated form
     * @var TIP_FORM_RENDER_...
     */
    protected $invalid_render = TIP_FORM_RENDER_IN_PAGE;

    /**
     * The render mode for validated form
     * @var TIP_FORM_RENDER_...
     */
    protected $valid_render = TIP_FORM_RENDER_IN_PAGE;

    /**
     * The URI to follow on cancel
     *
     * Leaves it null to use the default referer. If the action is processed,
     * all occurrences of {field} (where field is any valid field id) are
     * expanded to their own value. If the action fails but this URI
     * requires an expanded field, the default referer is used.
     *
     * @var string|null
     */
    protected $referer = null;

    /**
     * The URI to chain up at the end of the action
     *
     * Leaves it null to use the default referer. If the action is processed,
     * all occurrences of {field} (where field is any valid field id) are
     * expanded to their own value. If the action fails but the URI
     * requires an expanded field, the default referer is used.
     *
     * @var string|null
     */
    protected $follower = null;

    //}}}
    //{{{ Constructor/destructor

    static protected function checkOptions(&$options)
    {
        if (!parent::checkOptions($options) || !isset($options['master'], $options['action'])) {
            return false;
        }

        // Default values
        TIP::arrayDefault($options, 'id', $options['master']->getProperty('id'));
        TIP::arrayDefault($options, 'locale_prefix', 'form');
        TIP::arrayDefault($options, 'action_id', $options['action']);
        TIP::arrayDefault($options, 'referer', TIP::getRefererUri());
        TIP::arrayDefault($options, 'follower', $options['referer']);

        if (!isset($options['buttons'])) {
            switch ($options['action']) {

            case TIP_FORM_ACTION_ADD:
            case TIP_FORM_ACTION_EDIT:
                $options['buttons'] = TIP_FORM_BUTTON_SUBMIT|TIP_FORM_BUTTON_CANCEL;
                break;

            case TIP_FORM_ACTION_VIEW:
                $options['buttons'] = TIP_FORM_BUTTON_CLOSE;
                break;

            case TIP_FORM_ACTION_DELETE:
                $options['buttons'] = TIP_FORM_BUTTON_DELETE|TIP_FORM_BUTTON_CANCEL;
                break;

            default:
                $options['buttons'] = TIP_FORM_BUTTON_CLOSE;
            }
        }

        return true;
    }

    /**
     * Constructor
     *
     * Initializes a TIP_Form instance.
     *
     * @param array $options Properties values
     */
    protected function __construct($options)
    {
        parent::__construct($options);
        HTML_QuickForm::registerRule('unique', 'callback', '_ruleUnique', 'TIP_Form');
    }

    //}}}
    //{{{ Methods

    /**
     * Run the form
     *
     * Executes the requested action, accordling to the properties values set
     * in the constructor.
     *
     * @return bool|null true if the action is performed,
     *                   false if not or null on errors
     */
    public function run()
    {
        $valid = $this->validate();
        if ($valid)
            $this->process();
        $this->render($valid);
        return $valid;
    }

    /**
     * Define and validate the form
     *
     * @return bool|null true if the form validates,
     *                   false if not or null on errors
     */
    public function validate()
    {
        // Create the form
        $this->_form =& new HTML_QuickForm('__tip_' . $this->id, TIP_FORM_METHOD_POST, $_SERVER['REQUEST_URI'], '', null, true);
        $this->_form->removeAttribute('name');
        $this->_form->setRequiredNote($this->getLocale('required_note'));
        $this->_form->addElement('hidden', 'module', $this->id);
        $this->_form->addElement('hidden', 'action', $this->action_id);

        return $this->validateAlso($this->master);
    }

    /**
     * Append a module structure to the current form and validate
     *
     * @param  TIP_Content &$module The module owning the structure to append
     * @return bool|null            true if the form validates,
     *                              false if not or null on errors
     */
    public function validateAlso(&$module)
    {
        $this->_data =& $module->getProperty('data');

        // Initialize or merge the new fields in "fields" property
        if ($module == $this->master) {
            isset($this->fields) || $this->fields = $this->_data->getFields();
        } else {
            $this->fields += $this->_data->getFields();
        }

        $this->keys['HEADER'] = $module->getLocale('header.' . $this->action_id);
        $this->_form->addElement('header', '__tiph_' . $module, 'data');

        // Fill $this->_defaults
        $this->_addDatabaseDefaults();
        if ($this->action == TIP_FORM_ACTION_ADD) {
            $this->_addAutomaticDefaults();
        }
        $this->_addApplicationDefaults();

        array_walk(array_keys($this->fields), array(&$this, '_addWidget'));

        // Set the default content
        $this->_form->setDefaults($this->_defaults);

        if ($this->captcha) {
            $this->_addCaptcha();
        }

        ++ $this->_stage;
        return $this->_validate();
    }

    /**
     * Process the form
     *
     * Also resets the session stage counter on POST driven form to avoid
     * multiple calls.
     */
    public function process()
    {
        $this->_form->freeze();

        if ($this->action == TIP_FORM_ACTION_DELETE ||
            $this->action == TIP_FORM_ACTION_CUSTOM) {
            // GET driven form: this action could be called more than once
            $this->_processRow($this->_defaults);
        } else {
            // POST driven form: called only once
            HTTP_Session2::set($this->id . '.stage', null);
            $this->_form->process(array(&$this, '_processRow'));
        }

        if (strpos($this->referer, '-lastid-') !== false ||
            strpos($this->follower, '-lastid-') !== false) {
            // Deprecated use of '-lastid-', kept for compatibility
            $data =& $this->master->getProperty('data');
            $primary_key = $data->getProperty('primary_key');
            $lastid = @$this->_row[$primary_key];
            $this->referer = str_replace('-lastid-', $lastid, $this->referer);
            $this->follower = str_replace('-lastid-', $lastid, $this->follower);
        } elseif (is_null($this->_row)) {
            // Operation failed, no expansion possible: provide fallbacks
            if (strpos($this->referer, '{') !== false) {
                $this->referer = TIP::getRefererUri();
            }
            if (strpos($this->follower, '{') !== false) {
                $this->follower = TIP::getRefererUri();
            }
        } else {
            // New field expansion
            foreach ($this->_row as $key => &$value) {
                $id = '{' . $key . '}';
                $this->referer = str_replace($id, $value, $this->referer);
                $this->follower = str_replace($id, $value, $this->follower);
            }
        }
    }

    /**
     * Render the form
     *
     * @param  bool|null $valid Whether the form was validated
     * @return bool             true if the renderer was performed,
     *                          false on errors
     */
    public function render($valid)
    {
        $mode = $valid === false ? $this->invalid_render : $this->valid_render;
        if ($mode == TIP_FORM_RENDER_NOTHING) {
            return true;
        }

        // Add buttons
        $this->_addButtons($valid);

        // Form template initialization
        $template =& TIP_Application::getSharedTemplate($this->form_template);
        if (is_null($template)) {
            TIP::error("form template not found ($this->form_template)");
            return false;
        }

        // Some global keys
        $this->keys['ATTRIBUTES'] = $this->_form->getAttributes(true);
        $this->keys['REQUIREDNOTE'] = $this->_form->getRequiredNote();

        // Populate the array (if not yet done)
        if (is_null($this->_array)) {
            $renderer =& TIP_Renderer::getForm();
            $this->_form->accept($renderer);
            $this->_array = $renderer->toArray();
        }

        // Call the renderer
        if ($mode == TIP_FORM_RENDER_IN_PAGE) {
            $content =& TIP_Application::getGlobal('content');
            ob_start();
            $done = $template->run($this);
            $content .= ob_get_clean();
        } else {
            $done = $template->run($this);
        }

        return $done;
    }

    /**
     * Start a form view
     *
     * The available form views are:
     * - 'SECTION' to browse throught the form sections
     * - 'ELEMENT' to browse throught the elements of the current section
     *
     * @param  string        $type The view type
     * @return TIP_View|null       The view instance or null on errors
     */
    public function &startView($type)
    {
        switch ($type) {

        case 'SECTION':
            if (!is_array($this->_array)) {
                return null;
            }

            $this->_section_view =& TIP_Type::singleton(array(
                'type' => array('view', 'array_view'),
                'id'   => 'SECTION',
                'rows' => &$this->_array
            ), true);

            return $this->_section_view;

        case 'ELEMENT':
            if (is_null($this->_section_view) ||
                is_null($s_id = $this->_section_view->key())) {
                return null;
            }

            $this->_element_view =& TIP_Type::singleton(array(
                'type' => array('view', 'array_view'),
                'id'   => 'ELEMENT',
                'rows' => &$this->_array[$s_id]['elements']
            ), true);
            return $this->_element_view;
        }

        return null;
    }

    /**
     * End the current view
     * @return bool true on success or false on errors
     */
    public function endView()
    {
        if (isset($this->_element_view)) {
            $this->_element_view = null;
        } else {
            $this->_section_view = null;
        }
        return true;
    }

    /**
     * Return the value of a generic item
     *
     * Gets the value of a generic item. This implementation adds form
     * specific features to the TIP_Module::getItem() method, such as
     * the ability to get information from the current element or from
     * the current section.
     *
     * @param  string     $id The item id
     * @return mixed|null     The value of the item or null if not found
     */
    public function getItem($id)
    {
        if (isset($this->_element_view)
            && !is_null($value = $this->_element_view->getField($id))) {
            return $value;
        }

        if (isset($this->_section_view)
            && !is_null($value = $this->_section_view->getField($id))) {
            return $value;
        }

        return parent::getItem($id);
    }

    //}}}
    //{{{ Tags

    /**#@+
     * @param  string      $params Parameters of the tag
     * @return string|null         The string result or null on errors
     */

    protected function tagHidden($params)
    {
        $hidden = isset($this->_section_view) &&
            !is_null($s_id = $this->_section_view->key()) &&
            $header =& $this->_array[$s_id]['hidden'];
        return $hidden ? 'true' : 'false';
    }

    protected function tagForm($params)
    {
        $form =& $this->_form;
        return method_exists($form, $params) ? $form->$params() : null;
    }

    protected function tagSection($params)
    {
        if (!isset($this->_section_view) ||
            is_null($section_id = $this->_section_view->key())) {
            return null;
        }

        $section =& $this->_array[$section_id]['object'];
        return method_exists($section, $params) ? $section->$params() : null;
    }

    protected function tagElement($params)
    {
        if (!isset($this->_element_view) ||
            is_null($element_id = $this->_element_view->key())) {
            return null;
        }

        $element_rows =& $this->_element_view->getProperty('rows');
        $element =& $element_rows[$element_id]['object'];
        return method_exists($element, $params) ? $element->$params() : null;
    }

    /**#@-*/

    //}}}
    //{{{ Internal properties

    /**
     * A reference to the TIP_Data object of the current module in validation
     * @var TIP_Data
     * @internal
     */
    private $_data = null;

    /**
     * A reference to the form object
     * @var HTML_QuickForm
     * @internal
     */
    private $_form = null;

    /**
     * An associative array of element_id => callback that convert the
     * submitted values in usable form before the processing
     *
     * @var array
     * @internal
     */
    private $_converter = array();

    /**
     * The internal used tabindex counter
     * @var int
     * @internal
     */
    private $_tabindex = 0;

    /**
     * The current stage level
     * @var int
     * @internal
     */
    private $_stage = 0;

    /**
     * The rendered array used by the renderer
     * @var array
     * @internal
     */
    private $_array = null;

    /**
     * The temporary section view to use
     * @var array
     * @internal
     */
    private $_section_view = null;

    /**
     * The temporary element view to use
     * @var array
     * @internal
     */
    private $_element_view = null;

    /**
     * Complete collection of default values
     *
     * This array includes, in order from highest precedence:
     *
     * - GET defaults
     * - explicitely set defaults
     * - automatic defaults
     * - database defaults
     *
     * @var array
     * @internal
     */
    private $_defaults = array();

    /**
     * Wheter the processRow() callback must be transaction protected
     * @var boolean
     * @internal
     */
    private $_transaction_protected = false;

    /**
     * The content of the processed row, if the process succeeded
     * @var array|null
     * @internal
     */
    private $_row = null;

    //}}}
    //{{{ Callbacks

    public function _ruleUnique($value, $options)
    {
        $form_register =& TIP_Type::singleton('form');
        $var = array_keys($form_register);

        // The active form is the last registered form
        $form_id = end(array_keys($form_register));
        $form =& $form_register[$form_id];
        if ($form->action_id != TIP_FORM_ACTION_ADD && $form->action_id != TIP_FORM_ACTION_EDIT) {
            return true;
        }

        $filter = $form->_data->filter($options, $value);
        $rows =& $form->_data->getRows($filter);
        $valid = empty($rows);

        if (!$valid && count($rows) < 2) {
            // Check if the row edited by this form has the same primary key of
            // the found row
            $primary_key = $form->_data->getProperty('primary_key');
            $valid = @array_key_exists($form->_defaults[$primary_key], $rows);
        }

        return $valid;
    }

    public function _ruleDate($value)
    {
        list($day, $month, $year) = array_values($value);
        return checkdate($month, $day, $year);
    }

    private function _converterTimestamp(&$row, $field_id)
    {
        list($day, $month, $year) = array_values($row[$field_id]);
        $row[$field_id] = mktime(0, 0, 0, $month, $day, $year);
        return true;
    }

    private function _converterSqlDate(&$row, $field_id)
    {
        list($day, $month, $year) = array_values($row[$field_id]);
        $row[$field_id] = sprintf('%04d-%02d-%02d', $year, $month, $day);
        return true;
    }

    private function _converterSet(&$row, $field_id)
    {
        if (@is_array($row[$field_id])) {
            $row[$field_id] = implode(',', array_keys($row[$field_id]));
        }
        return true;
    }

    private function _converterCancel(&$row, $field_id)
    {
        $row[$field_id] = @$this->_defaults[$field_id];
        return true;
    }

    private function _converterPlaceholder(&$row, $field_id)
    {
        if (!empty($row[$field_id])) {
            return;
        }

        $dummy_row = array();
        $data =& TIP_Type::singleton(array(
            'type' => array('data'),
            'path' => $this->fields[$field_id]['widget_args']
        ));

        if (is_null($data) || !$data->putRow($dummy_row)) {
            return false;
        }

        $row[$field_id] = $data->getLastId();
        return true;
    }

    public function _processRow(&$row)
    {
        // Processed row null by default
        $this->_row = null;

        // Check "on_process" callback validity
        if (is_null($this->on_process)) {
            return;
        } elseif (!is_callable($this->on_process)) {
            TIP::error("invalid on_process callback passed to TIP_Form ($this->id)");
            return;
        }

        if ($this->_transaction_protected) {
            if (is_null($engine =& $this->_data->getProperty('engine'))) {
                return;
            }
        } else {
            $engine = null;
        }

        if ($engine && !$engine->startTransaction()) {
            // This error must be caught here to avoid the rollback
            return;
        }

        // Apply the converters on every field of $row
        $done = true;
        foreach ($this->_converter as $field => $type) {
            if (!$this->{'_converter' . $type}($row, $field)) {
                $done = false;
                break;
            }
        }

        // Run the process callback
        $done = $done && call_user_func_array($this->on_process, array(&$row, $this->_defaults));
        if ($done) {
            TIP::notifyInfo('done');
            $this->_row =& $row;
        } else {
            TIP::notifyError($this->action_id);
        }

        $engine && $engine->endTransaction($done);
    }

    //}}}
    //{{{ Internal methods

    /**
     * Add database defaults to $this->_defaults
     */
    private function _addDatabaseDefaults()
    {
        foreach ($this->fields as $id => &$field) {
            if (isset($field['default']) && !$field['automatic']) {
                $this->_defaults[$id] = $field['default'];
            }
        }
    }

    /**
     * Add automatic defaults to $this->_defaults
     */
    private function _addAutomaticDefaults()
    {
        if (array_key_exists('_creation', $this->fields)) {
            $this->_defaults['_creation'] = TIP::formatDate('datetime_sql');
        }

        if (array_key_exists('_lasthit', $this->fields)) {
            $this->_defaults['_lasthit'] = TIP::formatDate('datetime_sql');
        }

        if (array_key_exists('_user', $this->fields)) {
            $this->_defaults['_user'] = TIP::getUserId();
        }
    }

    /**
     * Add GET defaults to $this->defaults and merge them to $this->_defaults
     *
     * This default values will be merged to $this->defaults with
     * higher precedence.
     *
     * Default values provided by GET must be treated specially,
     * otherwise will be lost in a POST submission. A special hidden
     * input is used for such purpose.
     */
    private function _addApplicationDefaults()
    {
        // Check for GET default values
        $get_defaults = array();
        if ($this->_form->isSubmitted()) {
            // Get default values from the special POST (if present)
            $value = TIP::getPost('__tipd', 'string');
            empty($value) || $get_defaults = unserialize($value);
        } else {
            // Check for default values provided via GET
            foreach ($this->fields as $id => &$field) {
                // Skip application specific GETs
                if ($id == 'module' || $id == 'action' || $id == 'id') {
                    continue;
                }

                $type = isset($field['type']) ? $field['type'] : 'string';
                $value = TIP::getGet($id, $type);
                isset($value) && $get_defaults[$id] = $value;
            }

            $value = serialize($get_defaults);
        }

        if (!empty($get_defaults)) {
            // Merge GET defaults with explicitely set defaults
            if (is_array($this->defaults)) {
                $this->defaults = array_merge($this->defaults, $get_defaults);
            } else {
                $this->defaults = $get_defaults;
            }

            // Manage the __tipd special element
            if (!$this->_form->elementExists('__tipd')) {
                // No previous "__tipd" element found
                $this->_form->addElement('hidden', '__tipd', $value);
            } else {
                // The "__tipd" element is present: the new defaults
                // must be merged to its value with higher precedence
                $element =& $this->_form->getElement('__tipd');
                $old_value = $element->getValue();
                $old_defaults = unserialize($old_value);
                $get_defaults = array_merge($old_defaults, $get_defaults);
                $value = serialize($get_defaults);
                $element->setValue($value);
                // No needs to update $this->defaults: this must be
                // yet done by the previous operation that set '__tipd'
            }
        }

        // Finally merge the application defaults ($this->defaults) with
        // the global defaults ($this->_defaults)
        $this->_defaults = array_merge($this->_defaults, $this->defaults);
    }

    private function& _addElement($widget, $id, $attributes = false)
    {
        $label = $this->getLocale('label.' . $id);
        $comment = TIP::getLocale('comment.' . $id, $this->locale_prefix);
        if (is_string($attributes)) {
            $attributes = array('class' => $attributes);
        }
        $attributes['tabindex'] = ++ $this->_tabindex;

        $element =& $this->_form->addElement($widget, $id, $label, $attributes);
        $element->setComment($comment);

        return $element;
    }

    private function _addCaptcha()
    {
        HTML_QuickForm::registerElementType('captcha', 'HTML/QuickForm/captcha.php', 'HTML_QuickForm_captcha');

        $id = 'captchanw';
        $element =& $this->_addElement('captcha', $id, array('size' => 6, 'maxlength' => 6));
        $element->setLocale(TIP::getLocaleId());
        $this->_addRule($id, 'required');
        $this->_addRule($id, 'captcha');
    }

    private function _addWidget($id)
    {
        // Avoid duplicates
        if ($this->_form->elementExists($id))
            return;

        $field =& $this->fields[$id];
        $default = TIP::pickElement($id, $this->_defaults);

        // By default, fields starting with '_' and automatic fields
        // cannot be edited, so are included as hidden (if defined)
        if (substr($id, 0, 1) == '_' || $field['automatic']) {
            is_null($default) || $this->_form->addElement('hidden', $id, $default);
            return;
        }

        $flags = isset($field['flags']) ? explode(',', strtolower($field['flags'])) : array();
        $explicit_default = TIP::pickElement($id, $this->defaults);

        // Check for "placeholder" flag
        if (is_null($explicit_default) && in_array('placeholder', $flags)) {
            // Special case: placeholder flag and no default value provided
            // The widget must not be built. The value will be automagically
            // handled by _converterPlaceholder()
            $this->_transaction_protected = true;
            $this->_addConverter($id, 'Placeholder');
            return;
        }

        // Create the widget
        $method = '_widget' . @$field['widget'];
        method_exists($this, $method) || $method = '_widgetText';
        $element =& $this->$method($field, @$field['widget_args']);

        // Check for "immutable" flag and explicit default value provided
        if (!is_null($explicit_default) && in_array('immutable', $flags)) {
            $element->freeze();
        }

        // Check if the field is in the "readonly" list
        if (in_array($id, $this->readonly)) {
            $element->freeze();
        }

        // Remove comment if the element is frozen
        if ($element->isFrozen()) {
            $element->setComment(null);
        }
    }

    private function _addRule($id, $type, $format = '')
    {
        // Add the format as context to getLocale (in case the localized message
        // will embed any format field)
        if (is_array($format)) {
            $context = $format;
        } elseif (!empty($format)) {
            $context[0] = $format;
        } else {
            $context = null;
        }
            
        $message = $this->getLocale('rule.' . $type, $context);
        $result = $this->_form->addRule($id, $message, $type, $format, $this->validation);
        if (PEAR::isError($result)) {
            TIP::error($result->getMessage());
        }
    }

    private function _addGuessedRules($id)
    {
        $widget = strtolower(@$this->fields[$id]['widget']);
        $is_upload = in_array($widget, array('attachment', 'picture', 'thumbnail'));

        if (@$this->fields[$id]['category'] == 'required') {
            $this->_addRule($id, 'required');
            $is_upload && $this->_addRule($id, 'requiredupload');
        }

        if ($is_upload) {
            $this->_addRule($id, 'uploaded');
        } elseif (is_numeric($this->fields[$id]['default'])) {
            $this->_addRule($id, 'numeric');
        }
    }

    private function _addCustomRules($id)
    {
        $text = @$this->fields[$id]['rules'];
        if (empty($text)) {
            return;
        }

        $rules = explode(',', $text);
        foreach ($rules as $rule) {
            $open_brace = strpos($rule, '(');
            if ($open_brace === false) {
                $type = $rule;
                $format = '';
            } else {
                $close_brace = strrpos($rule, ')');
                if ($close_brace === false || $close_brace < $open_brace) {
                    TIP::warning("invalid custom rule for field $id ($rule)");
                    continue;
                }
                $type = substr($rule, 0, $open_brace);
                $format = substr($rule, $open_brace+1, $close_brace-$open_brace-1);
                if (strpos($format, ' ')) {
                    $format = explode(' ', $format);
                }
            }
            $this->_addRule($id, $type, $format);
        }
    }

    private function _addConverter($id, $type)
    {
        $this->_converter[$id] = $type;
    }

    /**
     * Configure an attachment based element
     *
     * This code can be shared by every HTML_QuickForm_attachment based element.
     *
     * @param  HTML_QuickForm_element &$element The element to configure
     * @param  string                  $args    The widget args
     * @return HTML_QuickForm_element           The configured element
     */
    private function &_configAttachment(&$element, $args)
    {
        // Common base path and uri
        $element->setBasePath(TIP::buildDataPath($this->id));
        $element->setBaseUrl(TIP::buildDataUri($this->id));

        // Unload the element data, if needed
        $unload_id = 'unload_' . $element->getName();
        if ($this->action == TIP_FORM_ACTION_DELETE &&
            TIP::getGet('process', 'int') == 1 ||
            array_key_exists($unload_id, $_POST)) {
            $element->setState(QF_ATTACHMENT_TO_UNLOAD);
        } else {
            // Add the unload element
            $unload_label = $this->getLocale('label.' . $unload_id);
            $unload_element = $this->_form->createElement('checkbox', $unload_id, $unload_label, $unload_label, array('tabindex' => $this->_tabindex));
            $element->setUnloadElement($unload_element);
        }

        return $element;
    }

    /**
     * Configure a picture based element
     *
     * This code can be shared by every HTML_QuickForm_picture based element.
     *
     * @param  HTML_QuickForm_element &$element The element to configure
     * @param  array                   $range   The allowed range, as returned
     *                                          by _getPictureRange()
     * @param  string                  $args    The widget args
     * @return HTML_QuickForm_element           The configured element
     */
    private function &_configPicture(&$element, $range, $args)
    {
        // A picture is an attachment derived element
        $this->_configAttachment($element, $args);

        // Set the autoresize feature, if requested
        $element->setAutoresize($args && strpos($args, 'autoresize') !== false);

        // Variable substitution in the element comment, if needed
        $comment = $element->getComment();
        if ($comment && strpos($comment, '|0|') !== false) {
            foreach ($range as $n => $value) {
                $comment = str_replace('|'.$n.'|', $value, $comment);
            }
            $element->setComment($comment);
        }

        return $element;
    }

    /**
     * Get the range of allowed picture size
     *
     * Analyzes the field rules ('minpicturesize' and 'maxpicturesize')
     * to get the range of the allowed picture size.
     *
     * @param  array &$field The field to analyze
     * @return array         The size range in the form
     *                       array(min_width,min_height,max_width,max_height)
     */
    private function _getPictureRange(&$field)
    {
        $range = array();

        if (preg_match('/minpicturesize\(([0-9]+) *([0-9]+)\)/', $field['rules'], $match)) {
            $range[0] = $match[1];
            $range[1] = $match[2];
        } else {
            $range[0] = $range[1] = 0;
        }

        if (preg_match('/maxpicturesize\(([0-9]+) *([0-9]+)\)/', $field['rules'], $match)) {
            $range[2] = $match[1];
            $range[3] = $match[2];
        } else {
            $range[2] = $range[3] = '&infin;';
        }

        return $range;
    }

    private function _validate()
    {
        if ($this->action == TIP_FORM_ACTION_DELETE ||
            $this->action == TIP_FORM_ACTION_CUSTOM) {
            // Special case: GET driven form
            $this->_form->freeze();
            return TIP::getGet('process', 'int') == 1;
        }

        // Perform uploads (if needed)
        if (is_callable(array('HTML_QuickForm_attachment', 'doUploads'))) {
            HTML_QuickForm_attachment::doUploads($this->_form);
        }

        // Add element and form rules
        isset($this->validator) && $this->_form->addFormRule($this->validator);
        foreach (array_keys($this->fields) as $id)
            if ($this->_form->elementExists($id)) {
                $this->_addGuessedRules($id);
                $this->_addCustomRules($id);
            }

        $stage_id = $this->id . '.stage';
        $last_stage = HTTP_Session2::get($stage_id);

        if (!$this->_form->isSubmitted() ||     // First submission
            isset($last_stage) && $last_stage < $this->_stage) {
            HTTP_Session2::set($stage_id, $this->_stage);
            $valid = false;
        } elseif (is_null($last_stage)) {       // No last stage defined
            TIP::notifyError('double');
            $valid = null;
        } else {                                // Validation
            $this->_form->applyFilter('__ALL__', array('TIP', 'extendedTrim'));
            $valid = $this->_form->validate();
        }

        return $valid;
    }

    /**
     * Append action buttons to the end of this form
     *
     * @param bool|null $valid Whether the form was validated
     */
    private function _addButtons($valid)
    {
        $buttons = $valid === false ? $this->buttons : TIP_FORM_BUTTON_CLOSE;
        $group = array();

        if ($buttons & TIP_FORM_BUTTON_SUBMIT) {
            $element =& $this->_form->createElement('submit', null, $this->getLocale('button.submit'), array('class' => 'ok'));
            $element->removeAttribute('name');
            $group[] =& $element;
        }
        if ($buttons & TIP_FORM_BUTTON_RESET) {
            $element =& $this->_form->createElement('reset', null, $this->getLocale('button.reset'), array('class' => 'restore'));
            $element->removeAttribute('name');
            $group[] =& $element;
        }
        if ($buttons & TIP_FORM_BUTTON_OK) {
            $uri = TIP::modifyActionUri(null, null, null, array('process' => 1));
            $element =& $this->_form->createElement('link', 'ok', null, $uri, $this->getLocale('button.ok'), array('class' => 'ok'));
            $element->removeAttribute('name');
            $group[] =& $element;
        }
        if ($buttons & TIP_FORM_BUTTON_DELETE && $this->action_id == TIP_FORM_ACTION_DELETE) {
            $uri = TIP::modifyActionUri(null, null, null, array('process' => 1));
            $element =& $this->_form->createElement('link', 'delete', null, $uri, $this->getLocale('button.delete'), array('class' => 'delete'));
            $element->removeAttribute('name');
            $group[] =& $element;
        }
        if ($buttons & TIP_FORM_BUTTON_CANCEL) {
            $element =& $this->_form->createElement('link', 'cancel', null, $this->referer, $this->getLocale('button.cancel'), array('class' => 'cancel'));
            $element->removeAttribute('name');
            $group[] =& $element;
        }
        if ($buttons & TIP_FORM_BUTTON_CLOSE) {
            $element =& $this->_form->createElement('link', 'close', null, $this->follower, $this->getLocale('button.close'), array('class' => 'close'));
            $element->removeAttribute('name');
            $group[] =& $element;
        }
        if ($buttons & TIP_FORM_BUTTON_DELETE && $this->action_id != TIP_FORM_ACTION_DELETE) {
            $data =& $this->master->getProperty('data');
            $primary_key = $data->getProperty('primary_key');
            $uri = TIP::buildActionUri($this->id, 'delete', $this->_form->getElementValue($primary_key));
            $element =& $this->_form->createElement('link', 'delete', null, $uri, $this->getLocale('button.delete'), array('class' => 'delete'));
            $element->removeAttribute('name');
            $group[] =& $element;
        }

        // Append the group of buttons to the form
        $this->_form->addElement('group', 'buttons', null, $group, ' ', false);
    }

    private function &_widgetText(&$field, $args)
    {
        $id = $field['id'];
        $element =& $this->_addElement('text', $id, 'expand');

        if (@$field['length'] > 0) {
            $element->setMaxLength($field['length']);
            $this->_addRule($id, 'maxlength', $field['length']);
        }

        return $element;
    }

    private function &_widgetPassword(&$field, $args)
    {
        $id = $field['id'];
        $element =& $this->_addElement('password', $id, 'expand');

        if (@$field['length'] > 0) {
            $element->setMaxLength($field['length']);
            $this->_addRule($id, 'maxlength', $field['length']);
        }

        if ($this->action_id == TIP_FORM_ACTION_ADD || $this->action_id == TIP_FORM_ACTION_EDIT) {
            $reid = 're' . $id;
            $reelement =& $this->_addElement('password', $reid, 'expand');

            // The repetition field must have the same features of the original,
            // so the field structure is copyed
            if (!array_key_exists($reid, $this->fields)) {
                $this->fields[$reid] = $field;
            }

            $this->_addRule(array($reid, $id), 'compare');
            if (@array_key_exists($id, $this->_defaults) && !array_key_exists($reid, $this->_defaults)) {
                $this->_defaults[$reid] = $this->_defaults[$id];
            }
        }

        return $element;
    }

    private function &_widgetEnum(&$field, $args)
    {
        $id = $field['id'];
        $label = $this->getLocale('label.' . $id);
        $comment = TIP::getLocale('comment.' . $id, $this->locale_prefix);
        $items = $this->_getChoices($field['choices'], $args, @$this->_defaults[$id]);

        if (count($items) > 3) {
            // On lot of available choices, use a select menu
            $element =& $this->_form->addElement('select', $id, $label, $items);
            $element->setAttribute('class', 'expand');
        } else {
            // On few available choices, use radio button
            $group = array();
            foreach ($items as $i_value => $i_label) {
                ++ $this->_tabindex;
                $item =& $this->_form->createElement('radio', $id, $label, $i_label, $i_value, array('tabindex' => $this->_tabindex));
                $group[] =& $item;
            }
            $element =& $this->_form->addElement('group', $id, $label, $group, null, false);
        }

        $element->setComment($comment);
        return $element;
    }

    private function &_widgetSet(&$field, $args)
    {
        $id = $field['id'];
        $label = $this->getLocale('label.' . $id);
        $comment = TIP::getLocale('comment.' . $id, $this->locale_prefix);
        $default = @explode(',', $this->_defaults[$id]);
        $items = $this->_getChoices($field['choices'], $args, $default);

        // Reset the defaults (a comma separated list of flags that are set):
        // the $this->_defaults[$id] variable will be defined in the foreach
        // cycle in the proper HTML_QuickForm format
        unset($this->_defaults[$id]);

        $group = array();
        foreach ($items as $i_value => $i_label) {
            $this->_defaults[$id][$i_value] = in_array($i_value, $default);
            ++ $this->_tabindex;
            $item =& $this->_form->createElement('checkbox', $i_value, $label, $i_label, array('tabindex' => $this->_tabindex));
            $group[] =& $item;
        }

        $this->_addConverter($id, 'set');
        $element =& $this->_form->addElement('group', $id, $label, $group);
        $element->setComment($comment);
        return $element;
    }

    private function &_widgetTextArea(&$field, $args)
    {
        HTML_QuickForm::registerElementType('wikiarea', 'HTML/QuickForm/wikiarea.php', 'HTML_QuickForm_wikiarea');

        $id = $field['id'];
        $element =& $this->_addElement('wikiarea', $id, 'expand');

        if (!empty($args)) {
            $rules = explode(',', $args);
        } elseif (array_key_exists('wiki_rules', $field)) {
            // DEPRECATED: use the "wiki_rules" option instead of widget args
            $rules = explode(',', $field['wiki_rules']);
        } else {
            $rules = null;
        }
        $element->setWiki(TIP_Renderer::getWiki($rules));
        $element->setCols('30');
        $element->setRows('10');

        return $element;
    }

    private function &_widgetDate(&$field, $args)
    {
        HTML_QuickForm::registerRule('date', 'callback', '_ruleDate', 'TIP_Form');

        $id = $field['id'];
        $label = $this->getLocale('label.' . $id);
        $comment = TIP::getLocale('comment.' . $id, $this->locale_prefix);

        // Set the date in a format suitable for HTML_QuickForm_date
        $sql_date = @$this->_defaults[$id];
        $timestamp = empty($sql_date) ? time() : TIP::getTimestamp($sql_date, 'sql');
        $this->_defaults[$id] = $timestamp;

        $field_year = date('Y', $this->_defaults[$id]);
        $this_year = date('Y');

        // $min_year > $max_year, so the year list is properly sorted in reversed
        // order
        $options = array(
            'language' => substr(TIP::getLocaleId(), 0, 2),
            'format'   => 'dFY',
            'minYear'  => $this_year+1,
            'maxYear'  => $field_year < $this_year-5 ? $field_year : $this_year-5
        );

        ++ $this->_tabindex;
        $element =& $this->_form->addElement('date', $id, $label, $options, array('tabindex' => $this->_tabindex));
        $element->setComment($comment);
        $this->_addRule($id, 'date');
        $this->_addConverter($id, 'SqlDate');
        return $element;
    }

    private function &_widgetAttachment(&$field, $args)
    {
        HTML_QuickForm::registerElementType('attachment', 'HTML/QuickForm/attachment.php', 'HTML_QuickForm_attachment');
        $element =& $this->_addElement('attachment', $field['id']);
        return $this->_configAttachment($element, $args);
    }

    private function &_widgetPicture(&$field, $args)
    {
        HTML_QuickForm::registerElementType('picture', 'HTML/QuickForm/picture.php', 'HTML_QuickForm_picture');
        $element =& $this->_addElement('picture', $field['id']);
        $range = $this->_getPictureRange($field);
        return $this->_configPicture($element, $range, $args);
    }

    private function &_widgetThumbnail(&$field, $args)
    {
        HTML_QuickForm::registerElementType('thumbnail', 'HTML/QuickForm/thumbnail.php', 'HTML_QuickForm_thumbnail');

        // Leave the default thumbnail path/url, that is
        // the base ones with 'thumbnail' appended
        $element =& $this->_addElement('thumbnail', $field['id']);
        $range = $this->_getPictureRange($field);

        // If set, the thumbnail size is equal to the minimum size
        if ($range[0] > 0 && $range[1] > 0) {
            $element->setThumbnailSize($range[0], $range[1]);
        }

        return $this->_configPicture($element, $range, $args);
    }

    private function &_widgetHierarchy(&$field, $args)
    {
        $id = $field['id'];
        $label = $this->getLocale('label.' . $id);
        $comment = TIP::getLocale('comment.' . $id, $this->locale_prefix);

        if (empty($args)) {
            // Try to get the hierarchy master module from the $cfg array
            global $cfg;
            foreach ($cfg as $module_id => &$options) {
                if (isset($options['master']) && $options['master'] == $this->id) {
                    $hierarchy_id = $module_id;
                    break;
                }
            }
        } else {
            // Explicitely defined in the widget args
            $hierarchy_id = $args;
        }

        // On master field not found, build a default one
        // by appending '_hierarchy' to this module id
        isset($hierarchy_id) || $hierarchy_id = $this->id . '_hierarchy';

        $hierarchy =& TIP_Type::getInstance($hierarchy_id);

        // Populate the option list, prepending an empty option
        $items = array(' ' => '&#160;');
        $rows =& $hierarchy->toRows();
        is_null($rows =& $hierarchy->toRows()) || $items += $rows;

        ++ $this->_tabindex;
        $element =& $this->_form->addElement('select', $id, $label, $items, array('tabindex' => $this->_tabindex, 'class' => 'expand'));
        $element->setComment($comment);
        return $element;
    }

    /**
     * Filter and localize a set of choices given a well-known filter string
     *
     * Applies the filter rules specified by $filter to the $choices array. 
     * $filter can contain an "allow" rule in the form
     * "allow(choice1 choice2 ...)", in which case only the specified choices
     * found in $choices will be returned, or a "deny" rule in the form
     * "deny(choice1 choice2 ...)", in which case the specified choices will
     * be stripped from the $choices array.
     *
     * The filtered array is then combined (as key) with its localized label
     * (as value).
     *
     * Keep in mind the default value (either explicit or defined by design)
     * should not be filtered.
     *
     * @param  array  $choices The subject array
     * @param  string $filter  The filter string
     * @param  mixed  $default The default value (or values if it is an array)
     * @return array           The filtered choices
     */
    private function _getChoices($choices, $filter, $default)
    {
        // Force default to be an array
        is_array($default) || $default = array($default);

        if (empty($filter)) {
            $keys = $choices;
        } elseif (($from = strpos($filter, 'allow(')) !== false) {
            $from += 6;
            $len = strpos($filter, ')') - $from;
            $specified = explode(' ', substr($filter, $from, $len));
            $specified = array_merge($specified, $default);
            $keys = array_intersect($choices, $specified);
        } elseif (($from = strpos($filter, 'deny(')) !== false) {
            $from += 5;
            $len = strpos($filter, ')') - $from;
            $specified = explode(' ', substr($filter, $from, $len));
            $specified = array_diff($specified, $default);
            $keys = array_diff($choices, $specified);
        }

        // Localize the keys, implicitily removing duplicated $keys
        foreach ($keys as $key) {
            $labels[$key] = $this->getLocale('label.' . $key);
        }

        return $labels;
    }

    //}}}
}
?>
