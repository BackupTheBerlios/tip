<?php
/* vim: set expandtab shiftwidth=4 softtabstop=4 tabstop=4 foldmethod=marker: */

/**
 * TIP_XML definition file
 *
 * LICENSE: This source file is subject to the New BSD license that is 
 * available through the world-wide-web at the following URI:
 * http://www.opensource.org/licenses/bsd-license.php
 * If you did not receive a copy of the New BSD License and are unable to
 * obtain it through the web, please send a note to license@php.net so we
 * can mail you a copy immediately.
 *
 * @author    Nicola Fontana <ntd@entidi.it>
 * @copyright Copyright &copy; 2009 Nicola Fontana
 * @license   http://www.opensource.org/licenses/bsd-license.php New BSD License
 * @package   TIP
 * @since     0.3.3
 */

/**
 * The XML data engine
 *
 * Interface to an XML file. It uses the SimpleXML object to access the
 * underlying XML file.
 *
 * The "path" property of TIP_Data should specify a file path relative to
 * the data root directory. The filter used in select operations must be
 * empty or a valid XPath espression.
 *
 * @package TIP
 */
class TIP_XML extends TIP_Data_Engine
{
    //{{{ Properties

    /**
     * The base XPath to use while filtering rows
     * @var string
     */
    protected $base_xpath = '/';

    /**
     * The row <container> item without braces: it defaults to 'record'
     * and must be inside the provided $base_xpath.
     * @var string
     */
    protected $row_container = 'record';

    //}}}
    //{{{ Costructor/destructor

    /**
     * Constructor
     *
     * Initializes a TIP_XML instance.
     *
     * $options inherits the TIP_Type properties, and add the following:
     * - $options['row_container']: the row container item, without
     *                              braces (defaults is 'record', meaning
     *                              <record> is the row container)
     *
     * @param array $options Properties values
     */
    protected function __construct($options)
    {
        parent::__construct($options);
    }

    //}}}
    //{{{ TIP_Data_Engine implementation

    public function query()
    {
        // Not implemented
        assert(false);
        return null;
    }

    public function fillFields(&$data)
    {
        $xml = $this->_getXML($data);
        if ($xml === false) {
            return false;
        }

        $rows = $xml->xpath('//' . $this->row_container);

        // Use the first row found as template
        $row = reset($rows);
        $fields =& $data->getFieldsRef();

        // Consider the row attributes as fields
        foreach ($row->attributes() as $id => $value) {
            $fields[$id] = array(
                'type'   => 'string',
                'widget' => null,
                'length' => 0
            );
        }

        // Also, consider its internal nodes as fields
        foreach ($row as $id => $value) {
            if ($id != $this->row_container) {
                // Ignore recursive fields, as the 'parent' field is
                // always added (check below)
                $fields[$id] = array(
                    'type'   => 'string',
                    'widget' => null,
                    'length' => 0
                );
            }
        }

        $primary_key = $data->getProperty('primary_key');
        if (!array_key_exists($primary_key, $fields)) {
            // Primary key not explicitly defined in the XML:
            // will be used an autogenerated sequence
            $fields[$primary_key] = array(
                'type'      => 'int',
                'widget'    => null,
                'length'    => 0,
                'automatic' => true
            );
        }

        // Always add a 'parent' field for non-linear models
        // (tree and hierarchies) as this recursion can only be checked
        // by traversing the whole model (and I want to avoid it)
        $fields['parent'] = array(
            'type'   => $fields[$primary_key]['type'],
            'widget' => null,
            'length' => $fields[$primary_key]['length']
        );

        return true;
    }

    public function &select(&$data, $filter, $fields)
    {
        $xml = $this->_getXML($data);
        if ($xml === false) {
            return null;
        }

        $nodes = $xml->xpath($this->base_xpath);
        $this->_primary_key = $data->getProperty('primary_key');
        $rows = $this->_nodesToRows($nodes);

        return $rows;
    }

    public function insert(&$data, &$rows)
    {
        // Not implemented
        assert(false);
        return null;
    }

    public function update(&$data, $filter, &$row)
    {
        // Not implemented
        assert(false);
        return null;
    }

    public function delete(&$data, $filter)
    {
        // Not implemented
        assert(false);
        return null;
    }

    public function dump($root)
    {
        // Not implemented
        assert(false);
        return false;
    }

    protected function transaction($action)
    {
        return true;
    }

    //}}}
    //{{{ Internal properties

    /**
     * The cached array of SimpleXML objects
     * @var array
     * @internal
     **/
    private $_xmls = array();

    /**
     * The primary key id, used internally
     * @var string
     * @internal
     **/
    private $_primary_key = null;

    //}}}
    //{{{ Internal methods

    private function &_getXML(&$data)
    {
        $file = TIP::buildDataPath($data->getProperty('path'));

        if (!array_key_exists($file, $this->_xmls)) {
            // Work-around to let SimpleXML be happy with the fucking
            // default namespace
            $xml_data = file_get_contents($file);
            if (is_string($xml_data)) {
                $xml_data = str_replace('xmlns=', 'fakens=', $xml_data);
                $xml = simplexml_load_string($xml_data);
            } else {
                $xml = false;
            }

            $this->_xmls[$file] = $xml;
            if ($xml === false) {
                TIP::error("failed to load XML file ($file)");
            }
        }

        return $this->_xmls[$file];
    }

    private function &_nodesToRows($nodes, $parent = null)
    {
        $rows = array();
        foreach ($nodes as $node) {
            foreach ($node->{$this->row_container} as $row) {
                $subnodes = false;
                $new_row = array();
                foreach ($row->attributes() as $id => $value) {
                    $new_row[$id] = (string) $value;
                }
                foreach ($row->children() as $id => $value) {
                    if ($id == $this->row_container) {
                        $subnodes = true;
                    } else {
                        $new_row[$id] = (string) $value;
                    }
                }
                isset($parent) && $new_row['parent'] = $parent;
                if (array_key_exists($this->_primary_key, $new_row)) {
                    $row_id = $new_row[$this->_primary_key];
                } else {
                    $row_id = count($rows);
                    $new_row[$this->_primary_key] = $row_id;
                }

                $rows[$row_id] = $new_row;

                if ($subnodes) {
                    // This is a recursive node, used by tree models
                    $subrows =& $this->_nodesToRows(array($row), $row_id);
                    $rows = array_merge($rows, $subrows);
                    unset($subrows);
                }
            }
        }

        return $rows;
    }

    //}}}
}
?>
