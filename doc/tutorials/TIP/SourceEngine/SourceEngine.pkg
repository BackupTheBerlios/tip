<refentry id="{@id}">
 <refnamediv>
  <refname>Source engines</refname>
 </refnamediv>
 <refsynopsisdiv>
  <author>
   Nicola Fontana
   <authorblurb>{@link mailto:ntd@users.sourceforge.net ntd@users.sourceforge.net}</authorblurb>
  </author>
 </refsynopsisdiv>
 <refsect1 id="{@id general}">
  <title>General informations</title>
  <para>The TIP_SourceEngine class provides an abstraction of the source parser. This means the TIP system does not relies on a specific template engine, but can use any implementation of this class.</para>
  <refsect2 id="{@id TIP_Source}">
   <title>The TIP_Source object</title>
   <para>The source templates are accessed by the TIP_Module object using a TIP_Source instance that holds a reference to the source engine in its $_engine private property and it is usually binded to a source file throught its $_path property.</para>
  </refsect2>
 </refsect1>
 <refsect1 id="{@id technical}">
  <title>Technical informations</title>
  <refsect2 id="{@id commands}">
   <title>Interaction between source templates and modules</title>
   <para>The source engine interacts with the modules by calling the TIP_Module::callCommand() method. This is the base of the interaction between source engines and modules.</para>
   <para>The callCommand method is defined in Module.php in the following form (the debug sections are stripped from the real source):</para>
   <para>
    <programlisting role="php">
    <![CDATA[
    function callCommand($command, $params)
    {
        $method = 'command' . strtolower($command);
        if (!method_exists($this, $method)) {
            $this->error("the method does not exist ($method)");
            return null;
        }

        return $this->$method($params);
    }
    ]]>
    </programlisting>
   </para>
   <para>As you can see, the command is defined as a module method with the 'command' string prefixed to its name. This means calling callCommand('html', 'test'), will generate the commandHtml('test') call.</para>
  </refsect2>
 </refsect1>
</refentry>
