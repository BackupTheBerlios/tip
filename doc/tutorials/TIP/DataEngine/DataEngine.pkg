<refentry id="{@id}">
 <refnamediv>
  <refname>Data engines</refname>
 </refnamediv>
 <refsynopsisdiv>
  <author>
   Nicola Fontana
   <authorblurb>{@link mailto:ntd@users.sourceforge.net ntd@users.sourceforge.net}</authorblurb>
  </author>
 </refsynopsisdiv>
 <refsect1 id="{@id general}">
  <title>General informations</title>
  <para>The TIP_Data_Engine class provides the abstract base class for all the data engine implementations of the TIP system.</para>
  <refsect2 id="{@id TIP_Data}">
   <title>The TIP_Data object</title>
   <para>The data is accessed from a data source (a TIP_Data instance) that holds a reference to the data engine in its $_engine property and it is usually binded to a database table or a file throught its $_path property.</para>
   <para>All the modules will request data using a TIP_Data instance, and no other class will have access to the data engine.</para>
   <para>Furthermore, the TIP_Data instance is a singleton class (based on the TIP_Type mechanism) that use the engine name and the $_path property as its id, so two modules can share the same data if they have the same data engine and path.</para>
   <para>Remember also that, in TIP, all the data are based on a primary key access, that is there must be, for every data row, a field that identify this row. This is the primary key field, stored in the $primary_key public property of the TIP_Data class. It is named by default 'id', but can be easely changed to any other valid field id.</para>
  </refsect2>
  <refsect2 id="{@id rows}">
   <title>How to join tables?</title>
    <para>The TIP_Data object can also manage simple joined data tables. This is done by specifing the 'data_joins' configuration option of a block in the following way:</para>
   <para>
    <programlisting role="php">
    <![CDATA[
    $_joins = array(
        joined_table1  => array(
            'master'   => name of a field in the master table,
            'slave'    => name of a field in the joined table,
            'fieldset' => array of field names in the joined table to bind to this data
        ),
        ...
    );
    ]]>
    </programlisting>
   </para>
   <para>The only supported joins are 'LEFT JOIN' and are connected only using the '=' operator.</para>
   <para>To avoid conflicts between the fields of the various tables (master and binded ones), you can specify an alias for the binded fields as a key in the 'fieldset' array.</para>
   <para>If the joins are properly configured, the fieldsets of the joined tables are added to the rows in the same way as the calculated fields are, so you can use them as any other field.</para>
  </refsect2>
 </refsect1>
 <refsect1 id="{@id technical}">
  <title>Technical informations</title>
  <para>There are two primitive data to consider: the 'fields' and the 'rows' (also called records). Obviously, all the implementations must return these two data in a form suitable for TIP.</para>
  <para>This chapter contains the detailed definitions of such data structures.</para>
  <refsect2 id="{@id fields}">
   <title>The fields</title>
   <para>The fields represent the columns of a data source. The collection of these column informations is often referred as structure.</para>
   <para>Every module usually yet knows about its structure and the data is accessed by row, so no intensive use of fields is done. Anyway, there is a particular module where the fields are fundamental: the TIP_Form module.</para>
   <para>The fields are kept in the $_fields private property of TIP_Data, that can be changed only by the data engine.</para>
   <para>This property is filled on request (by calling TIP_Data::getFields()), but can be populated by the data engine at any time. This should allow a sort of performance gain if filled, for example, after a select query.</para>
   <para>This is the proper format of the $_fields property:</para>
   <para>
    <programlisting role="php">
    <![CDATA[
    $fields = array(
            'fieldid1' => array(

                // Filled by TIP_Data_Engine::fillFields()
                'id'          => 'fieldid1' (must be ever a string type),
                'type'        => a valid settype() type string,
                'widget'     => a valid form element or null (check the TIP_Form documentation),
                'length'      => an integer specifing the max length, or 0 if not used,
                'can_be_null' => true or false,

                // Filled by TIP_Data_Engine::fillDetails()
                'default'     => default value,
                'automatic'   => true if the field is set by the server,
                'choices'     => array of valid values for 'set' or 'enum' widgets,
                'info'        => a string of custom informations (see below)
                ...),

            ...);
    ]]>
    </programlisting>
   </para>
   <para>The reason to split the fields filling procedure in two step is performance. While the fillFields() operation is quite inexpensive and often required, getting the field details is usually a relative expensive operation and required only for automatic form generation.</para>
   <para>If you are implementing a new data engine and there is no need to split this operation, simply implement fillFields() only and code fillDetails() as following:</para>
   <para>
    <programlisting role="php">
    <![CDATA[
    function fillDetails (&$data);
    {
        return true;
    }
    ]]>
    </programlisting>
   </para>
  </refsect2>
  <refsect2 id="{@id info}">
   <title>The 'info' property of the fields structure</title>
   <para>The special key 'info' in the array of a single field is specially managed by the TIP_Data structure.</para>
   <para>Its format must be as follow:</para>
   <para>
    <programlisting role="php">
    <![CDATA[
    $field['info'] = 'key1=value1|key2=value2| ... |key?=value?';
    ]]>
    </programlisting>
   </para>
   <para>This pairs are merged by TIP_Data::getFields() to the source field array to provide extra informations, especially useful while constructing a form. Furthermore, these pairs OVERRIDE the original values of the field array.</para>
   <para>
    <programlisting role="php">
    <![CDATA[
    // This field structure filled by the data engine ...
    $fields = array(
            'content' => array(
                'id'          => 'content',
                'type'        => 'string',
                'widget'     => null,
                'length'      => 200,
                'can_be_null' => false,
                'default'     => '',
                'automatic'   => false,
                'choices'     => null,
                'info'        => 'category=required|order=3|widget=textarea');

    // ... will be returned by TIP_Data::getFields() as follow:
    $fields = array(
            'content' => array(
                'id'          => 'content',
                'type'        => 'string',
                'widget'     => 'text',
                'length'      => 32,
                'can_be_null' => false,
                'default'     => '',
                'automatic'   => true,
                'choices'     => null,
                'info'        => 'category=required|order=3|widget=textarea',
                'category'    => 'required',
                'order'       => '3');
    ]]>
    </programlisting>
   </para>
   <para>Check the documentation of TIP_Form to see what can you do with this additional informations.</para>
  </refsect2>
  <refsect2 id="{@id rows}">
   <title>The rows</title>
   <para>Differently from the fields, rows are generated by request, not binded to a specific TIP_Data object.</para>
   <para>The TIP_Block module provides a way to cache rows requests using the TIP_View approach: consult the documentation for further details.</para>
   <para>Anyway, the TIP_Data::getRows() method must return the rows in an homogeneous way, indipendently from the data engine used. Calling $rows the return value of getRows, this is the proper format of $rows:</para>
   <para>
    <programlisting role="php">
    <![CDATA[
    $rows = array(

            // First row
            PrimaryKey1 => array(
                id of field 1 => value of field 1 in the first row,
                id of field 2 => value of field 1 in the first row,
                ...),

            // Second row
            PrimaryKey2 => array(
                id of field 1 => value of field 1 in the second row,
                id of field 2 => value of field 2 in the second row,
                ...),

            ...);
    ]]>
    </programlisting>
   </para>
   <para>Of course, the result can be an empty array if there's no matching rows that satisfy the conditions specified while callind getRows.</para>
  </refsect2>
 </refsect1>
</refentry>
